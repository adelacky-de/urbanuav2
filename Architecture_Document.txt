# Urban UAV Corridors - System Architecture

This document describes the current architecture of the Urban UAV Corridors web application, outlining the frontend, backend, data layer, deployment environments, and user interaction scenarios.

## 1. Frontend Architecture
*   **Framework:** React 18 with TypeScript.
*   **Build Tool:** Vite.
*   **3D Map Engine:** CesiumJS. Extensively used for rendering 3D globes, 3D extruded polygons (Network), flat generic polygons (2D Corridors), and footprint extrusions (HDB Buildings).
*   **UI Components:** Custom minimalist React components (no external UI libraries like MUI or Tailwind):
    *   `LayerPanel.tsx`: Collapsible top-left panel to toggle layers, colors, and opacity.
    *   `NavigationBall.tsx`: Bottom-right widget to control the Cesium camera (orbit, tilt, zoom to Singapore).
    *   `InfoBar.tsx`: Bottom menu that slides up to display metadata when a geometric feature is clicked.
*   **Data Fetching:** Standard `fetch` API located in `api.ts`. The application previously used dynamic bounding box queries (`mapBbox`), but natively loads the entire datasets on initial mount (`App.tsx`) to prevent infinite loading loops.

## 2. Backend Architecture
*   **Framework:** FastAPI (Python).
*   **Server:** Uvicorn ASGI server.
*   **Original Design:** Intended to connect to a PostGIS database to perform dynamic spatial queries (`ST_Intersects`, `ST_MakeEnvelope`) based on the frontend viewer's bounding box.
*   **Current Design (Static File Serving):** Due to strict limitations and initialization failures with managed PostgreSQL databases on the deployment platform, the backend was completely refactored. The PostGIS dependency (`psycopg2`) was removed. 
*   **Operation:** The FastAPI server now reads three large `.geojson` files from the local disk into RAM during the app startup (`lifespan` event) and serves these static JSON strings directly to the frontend via `/2d-corridors`, `/3d-network`, and `/hdb-footprints`.

## 3. Data Used, Database, and API
*   **Database:** None. The PostgreSQL and PostGIS architecture has been bypassed to immediately unblock production deployment.
*   **Data Sources:**
    *   `2D_safe_corridors_prioritized.geojson` (flat flight paths)
    *   `3D_merged_network.geojson` (extruded 3D flight volumes with `min_altitude` and `max_altitude`)
    *   `hdb_footprints.geojson` (10,000+ building footprints for contextual rendering)
*   **API Endpoints:**
    *   `GET /health`: Returns `{"status": "ok", "mode": "static_file_serving"}`.
    *   `GET /2d-corridors`: Returns the complete 2D FeatureCollection.
    *   `GET /3d-network`: Returns the complete 3D FeatureCollection.
    *   `GET /hdb-footprints`: Returns the complete HDB FeatureCollection.

## 4. Deployment
*   **Frontend Deployment:** Vercel. 
    *   URL: `https://urbanuav2-*.vercel.app`
    *   Git Repository: `https://github.com/adelacky-de/urbanuav2` (Client)
    *   Vercel acts as a static host for the compiled React SPA.
*   **Backend Deployment:** Railway.
    *   URL: `https://brave-youthfulness-production-5dcd.up.railway.app`
    *   Git Repository: `https://github.com/adelacky-de/urban-uav-backend` (FastAPI)
    *   Environment Variables:
        *   `PORT=8000`
        *   `DATABASE_URL=postgresql://postgres:sMLULwzfGkbXmJsPIZgjRVEtuCwUtmiV@shinkansen.proxy.rlwy.net:22459/railway`
    *   **Folder Structure & Interaction:**
        *   The Railway service is instructed to use the `/fastapi` sub-directory as the root directory for the build context.
        *   `fastapi/main.py`: The entry point for the Uvicorn ASGI server.
        *   `fastapi/*.geojson`: The three large data files (2D corridors, 3D network, HDB footprints) physically reside inside the `fastapi/` folder. During Server start up (`lifespan`), `main.py` explicitly reads these JSON files from the local disk into RAM.
        *   **Interaction:** When the Vercel Frontend calls `GET https://brave-youthfulness-production-5dcd.up.railway.app/hdb-footprints`, Railway routes the request to the running `main.py` container. Because the 16MB of GeoJSON data was loaded into RAM during startup from the bundled local files, FastAPI instantly returns the massive JSON string back to the browser.

## 5. User Scenarios & Interactions
1.  **Initial Load:** The user navigates to the Vercel URL. The React application mounts and immediately fetches all three GeoJSON datasets from the Railway API. A "Loading Spatial Data..." overlay is shown.
2.  **Exploration:** The user sees a 3D globe centered on Singapore. They can use the mouse (drag to pan, scroll to zoom, ctrl+drag to tilt) or the `NavigationBall` arrows to explore the cityscape.
3.  **Layer Toggling:** The user clicks the "Layers" tab in the top left. They can toggle the visibility of the 2D Corridors, 3D Network, and HDB Footprints. They can also dynamically change the color of the 2D Corridors and HDB Footprints using the native HTML color picker, or adjust the opacity using the sliders.
4.  **Feature Interrogation:** The user physically clicks on a rendered polygon (e.g., a green 3D flight volume). The application highlights the specific polygon in yellow and opens the `InfoBar` at the bottom of the screen. The InfoBar dynamically generates a clean HTML table displaying all properties associated with that specific spatial feature (e.g., `priorityID`, `min_altitude`, `height`).

---
**Bugs Encountered & Solutions:**

1. **Infinite Data Fetching Loops:** 
   - *Bug:* Dynamic bounding box spatial queries triggered rapid, continuous data fetches during map navigation, crashing the browser.
   - *Solution:* Migrated the architecture to statically serve the complete GeoJSON payloads once on initial load, bypassing complex managed PostGIS dependencies.
2. **Production Network 404 Errors:** 
   - *Bug:* The Vercel frontend failed to reach the Railway backend in production due to relative pathing.
   - *Solution:* Configured a direct, explicit `VITE_API_BASE_URL` environment variable within Vercel to aggressively target the deployed Railway API.
3. **Cesium 3D Geometry Crashes (`reading 'x' of undefined`):** 
   - *Bug:* Backend GeoJSON data was originally encoded using raw Singapore SVY21 meters (EPSG:3414). Because Cesium natively requires WGS84 (EPSG:4326), it clamped the 30,000+ coordinates directly to the mathematical North Pole. This destroyed the building geometries and caused fatal triangulator division-by-zero bounds crashes.
   - *Solution:* Completely re-projected all 16MB of GeoJSON files via GeoPandas into proper EPSG:4326 Longitude/Latitude format. A frontend "Shoelace Algorithm" area validator was also deployed to actively drop any mathematical zero-area features before they reach the 3D renderer.


